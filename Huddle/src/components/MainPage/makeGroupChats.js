import { db } from '../../firebase/configFirebase';
import {
  doc,
  getDoc,
  writeBatch,
  arrayUnion,
  setDoc,
} from 'firebase/firestore';

//NEED TO FIX/CHANGE ALL OF THIS SHIT

export const createGroupChats = async (nearbyPeople, currentUser) => {
  try {
    // Find users not in any group chat
    const usersNotInGroup = nearbyPeople.filter(
      (user) => !user.groupchats || user.groupchats.length === 0
    );

    // Auto-create group if 4+ users are available
    if (usersNotInGroup.length >= 4) {
      await createAutoGroupChat(usersNotInGroup);
    }

    // Process existing group chats - add nearby users to existing groups
    await addUsersToExistingGroups(allUsers);
  } catch (error) {
    console.error('Error in createGroupChats:', error);
  }
};

// Create new auto group chat for users not in any group
const createAutoGroupChat = async (users) => {
  try {
    // Create deterministic group ID
    const memberUids = users.map((u) => u.id).sort();
    const groupId = `auto_${memberUids.join('_')}`;

    // Check if group already exists
    const groupRef = doc(db, 'groupChats', groupId);
    const groupDoc = await getDoc(groupRef);

    if (!groupDoc.exists()) {
      console.log('Creating new auto group chat');

      // Use batch for atomic operations
      const batch = writeBatch(db);

      // Create group chat document
      batch.set(groupRef, {
        id: groupId,
        type: 'auto', // Add this field
        name: `Local Group (${users.length} people)`, // Add a name field
        participants: memberUids,
        participantCount: memberUids.length, // Add participant count
        participantNames: users.reduce((acc, user) => {
          acc[user.id] = user.name;
          return acc;
        }, {}),
        createdAt: new Date(),
        isAutoGenerated: true,
        lastMessage: null,
        lastMessageTime: null,
        // Add any other fields that PublicChatsPage expects
      });

      // Update each user's groupchats array
      memberUids.forEach((uid) => {
        const userRef = doc(db, 'users', uid);
        batch.update(userRef, {
          groupchats: arrayUnion(groupId),
        });
      });

      await batch.commit();
      console.log('Auto group chat created successfully');
    }
  } catch (error) {
    console.error('Error creating auto group chat:', error);
  }
};

// Add nearby users to existing group chats
const addUsersToExistingGroups = async (allUsers) => {
  try {
    const batch = writeBatch(db);
    const groupsToUpdate = new Set();
    const userUpdates = new Map();

    // Collect all unique group chat IDs
    const allGroupIds = new Set();
    allUsers.forEach((user) => {
      if (user.groupchats) {
        user.groupchats.forEach((groupId) => allGroupIds.add(groupId));
      }
    });

    // Process each group
    for (const groupId of allGroupIds) {
      const groupRef = doc(db, 'groupChats', groupId);
      const groupDoc = await getDoc(groupRef);

      if (groupDoc.exists()) {
        const groupData = groupDoc.data();
        const existingParticipants = groupData.participants || [];
        const participantNames = groupData.participantNames || {};

        let groupUpdated = false;

        // Check each nearby user
        allUsers.forEach((user) => {
          // If user has this group but isn't in participants, add them
          if (
            user.groupchats?.includes(groupId) &&
            !existingParticipants.includes(user.id)
          ) {
            existingParticipants.push(user.id);
            participantNames[user.id] = user.name;
            groupUpdated = true;
          }

          // If user is nearby and group has space, add them
          else if (
            !user.groupchats?.includes(groupId) &&
            !existingParticipants.includes(user.id)
          ) {
            existingParticipants.push(user.id);
            participantNames[user.id] = user.name;
            groupUpdated = true;

            // Track user update needed
            if (!userUpdates.has(user.id)) {
              userUpdates.set(user.id, []);
            }
            userUpdates.get(user.id).push(groupId);
          }
        });

        // Update group if changes were made
        if (groupUpdated) {
          batch.update(groupRef, {
            participants: existingParticipants,
            participantNames: participantNames,
          });
          groupsToUpdate.add(groupId);
        }
      }
    }

    // Update users' groupchats arrays
    userUpdates.forEach((groupIds, userId) => {
      const userRef = doc(db, 'users', userId);
      groupIds.forEach((groupId) => {
        batch.update(userRef, {
          groupchats: arrayUnion(groupId),
        });
      });
    });

    // Commit all changes atomically
    if (groupsToUpdate.size > 0 || userUpdates.size > 0) {
      await batch.commit();
      console.log(
        `Updated ${groupsToUpdate.size} groups and ${userUpdates.size} users`
      );
    }
  } catch (error) {
    console.error('Error adding users to existing groups:', error);
  }
};
